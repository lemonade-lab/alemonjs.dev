---
label: '接口'
sidebar_position: 3
---

# 接口

:::info

捕获事件后可进行的

:::

## `useMessage`

> 在响应事件（如消息被创建）时，发送消息。

```ts title="src/response/**/*/res.ts"
import { useMessage, Format } from 'alemonjs'
export default e => {
  const [message] = useMessage(e)
  const format = Format.create().addText('hello word')
  message.send({ format })
}
```

## `useMention`

> 解析得到被提及的数据

```ts title="response/**/*/res.ts"
import { useMention } from 'alemonjs'
export default async (event, next) => {
  const [mention] = useMention(event)
  // 查找用户类型的 @ 提及，且不是 bot
  const user = await mention.findOne()
  // 数据长度为0，或数据中没有用户信息
  if (!user.count || !user.data) {
    return // 未找到用户Id
  }

  console.log('User:', user)

  // 处理被AT的用户...
}
```

## `useSubscribe`

> 订阅模式，在某个事件周期中进行观察

> ! 不可以在 回调中调用 subscribe.cancel(sub)

```ts title="response/**/*/res.ts"
import { Format, useMessage, useSubscribe } from 'alemonjs'

export default event => {
  const [message] = useMessage(event)
  const [subscribe] = useSubscribe(event, [
    'message.create',
    'private.message.create'
  ])

  message.send({
    format: Format.create()
      .addText('请输入密码')
      .addText('123456', { style: 'bold' })
  })

  // 订阅 res 挂载之前的
  const sub = subscribe.mount(
    (event, next) => {
      // 回调内不可调用 subscribe.cancel(sub)
      // 该设计已在 v2.1.17 版本修复
      // 创建
      const [message] = useMessage(event)
      // 获取文本
      const text = event.MessageText
      // 检查
      if (text === '123456') {
        message.send({
          format: Format.create().addText('密码正确')
        })
        clearTimeout(timeout)
      } else if (text == '/close') {
        message.send({
          format: Format.create().addText('取消登录')
        })
        clearTimeout(timeout)
      } else {
        message.send({
          format: Format.create().addText('密码不正确')
        })
        // 继续
        next()
        // 需要注意的是，sub 会在正常的周期中多出2个next。
        // 保持订阅，next()
        // 保持订阅且传递给下一个订阅, next(true)
        // 保持订阅且传递给下一个周期, next(true,true)
        // 如果想取消订阅，但继续传递给下一个订阅。
        // 则调用 next(true) 再调用 subscribe.cancel(sub)
        // 因为sub的next会自带继续订阅逻辑。
        // 该逻辑和next最初设计造成了一些困扰，在后续版本中会考虑优化。
      }
    },
    ['UserId']
  )

  const timeout = setTimeout(() => {
    // 取消订阅
    subscribe.cancel(sub)
    // 发送消息
    message.send({
      format: Format.create().addText('登录超时')
    })
  }, 1000 * 10)
}
```
